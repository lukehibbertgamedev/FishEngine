
My computer currently sees the Vulkan API as version 1.2.XX and not 1.3.XX so some functions are replaced with older types.

-----------------------------------------------------------------------------------------------------------------------------

Ensure CMakeLists.txt is updated per file created:

You are using Vulkan API version 1.2.178 at the maximum. Your driver does not currently support Vulkan 1.3.XXX

-----------------------------------------------------------------------------------------------------------------------------

Shader files

Using this command in the directory of the *.vert or *.frag file: glslangValidator.exe "shader.vert" -V -l -o "shader.vert.spv"
You will get the shader module that vulkan likes.
Don't forget to rebuild the root CMake file first (this will include it into the project source).
(go to gui, it should be there but if not then src = /Fish/ and bin = /Fish/code/ then generate)
See init_pipelines() for how to load the module.

If when compiling a shader, this process fails, it will come up as the pipeline compilation failing.

To create input/output variables via shader, we use 'layout (location = 0) out vec3 outColor;'.
layout location = n is a decorator that lets us add extra data to variable declarations and other things in GLSL.
The location refers to a slot, I assume in memory. 
Typically, we pass data from the vertex shader into the pixel/fragment shader.

Output variable: layout (location = 0) out vec3 outColour;
Input variable: layout (location = 0) in vec3 inColour;
The names are not entirely important to match, although they should, but the decorator location does matter.

-----------------------------------------------------------------------------------------------------------------------------

For each file that you create, CMakeLists.txt needs to know so it can be added to the executable.
This is the one within root/CMakeLists.txt.

-----------------------------------------------------------------------------------------------------------------------------

ImageView creation is hardcoded to have a tiling of OPTIMAL, but if you want to read image data
from the CPU then you need to use a tiling of LINEAR.

-----------------------------------------------------------------------------------------------------------------------------

Potential optimisation technique - Submit the same command buffer multiple times: 

Record the commands you need once, and submit them to the command queue each frame. 
This is useful to avoid recording commands into the buffer per frame, but for tutorial's sake
we do this anyway as it shows more of a render engine technique.
This is only useful if you are sure that the commands won't be changed on a per-frame basis.
This is a picky technique as recording commands is relatively cheap, but worth noting.

-----------------------------------------------------------------------------------------------------------------------------

Potential optimisation technique - Not storing function callbacks for the deletion queue:

Within the deletion queue struct:
std::function stores a lambda, and we can use it to store a callback with some data, which is perfect for this case.
Doing callbacks like this is inneficient at scale, because we are storing whole std::functions for every object we are 
deleting, which is not going to be optimal. For the amount of objects we will use in this tutorial, its going to be fine. 
But if you need to delete thousands of objects and want them deleted faster, a better implementation would be to store 
arrays of vulkan handles of various types such as VkImage, VkBuffer, and so on. And then delete those from a loop.

-----------------------------------------------------------------------------------------------------------------------------

Initialisation of Vulkan structures:

With Vulkan structures, it is very important that we do this `VkCommandPoolCreateInfo commandPoolInfo = {};`
By doing ` = {}`, we are letting the compiler initialize the entire struct to zero. 
This is critical, as in general Vulkan structs will have their defaults set in a way that 0 is 
relatively safe. By doing that, we make sure we don’t leave uninitialized data in the struct.